System Entities: (1) User (2) Group
Permission Types: ReadOnly, Checkout, CreateNew, Modify, All

Preliminary Ideas:
1) Permissions are applied on a per: (1) Resource, (2) Version basis.
2) Creation rights are going to have to exist globally as you cannot assign a right to something that does not exist.
3) Groups are loaded on server initialization to prevent many reads from the storage system.

Problems:
1) When a user creates a new resource or a new version, what rights do they and others get?
	A) Inherited - this is the best solution as it requires less input from the creator but allows for fine grained control if desired.
	B) Specifically assigned - lots of input required for each.
2) How will rights inheritance work?
	A) Cascading inheritance calculated from version 0 - this is extremely intensive as each right must be calculated.
	B) Forward rolling - when created a new resource or version will pickup the most recent rights from the last.
		i) Problem - rights between versions can differ, meaning an older version could be used to circumvent rights over a newer version.
	C) Resource as base - Base rights are rolled forward from the resource to the version then made changable on the version.
		i) Problem - see (B)(i).

Inheritance of Rights:
1) Global Rights (id=globaluserrights) - Creation of resources is a global right - users can either create a resource or not.
	A) Global rights will be loaded to the storage.security system on initialization.
	B) Available Rights:
		i) Create - User(s) can create new resources.
		ii) Statistics - User(s) can get statistics.
2) Resource Rights - ReadOnly, Checkout and Modify are all assessed on a per resource basis.
	A) Available Rights: 
		i) ReadOnly - User(s) can only read the resource, they cannot save changes - required for getting without checkout.
		ii) Checkout - User(s) can get a resource prohibiting others from making checking out.  Implies the ability to checkin thus making a new version.
		iii) Modify - User(s) can modify the most recent version without creating a new version.
		iv) VersionControl - User(s) can rollback the current version to a previous state.
		v) Delete - User(s) can delete the resource and all versions from the system.
		vi) All - all the above.
3) Version Rights - are completely inherited from resource, version rights do not exist.
4) Resource Rights Template - the base rights for all new resources.

Design
Storage.Security.Authorization.Manager - gateway to authorization

Storage.Security.Authorization.PermissionType - enumeration of available rights

Storage.Security.Authorization.Request - represents a user's request for authorization

Storage.Security.Authorization.Retriever - Fetches rights information from the DB
1) Supports fetching of global rights
2) Supports fetching of resource rights

Storage.Security.Authorization.Saver - Saves rights information to the DB
1) Supports fetching of global rights
2) Supports fetching of resource rights

Storage.Security.Authorization.Response - represents the usage rights for the global or resource

Flow
GET: Implementor -> Engine (gets resource & version) -> Authorization (checks rights on resource) -> Gives complete response with error for permissions or gives good response.
PUT: Implementor -> Engine (gets resource) -> Authorization (checks rights on resource or globals) -(Failure)> Gives complete response with error.
																								   -(Success)> Engine (puts version) -> Gives a good complete response.

Design Summary: Authorization can always expect to be given the resource or globals object with the necessary populated properties (user rights).