Overview: Transactions exist to handle cases where multiple commands combine in series.  This can be done to generate a single object or multiple objects.

Multiple Inputs, Single Output
A transaction accepts multiple steps as an input and then gives a single output.  In the event of a write type action, a transaction's output goes to couchdb; however, with a read the output goes to the 
implementing software.  In both cases, inputs can be gathered from multiple locations within the storage library which can get this information from couchdb or other locations.  This means that a transaction
needs to support multiple forms of input.

Stages
Transactions need to support multiple "steps" or "stages".  Stages need to be capable of being run and generating their output at different intervals.  For example Stage1 might run immediately, but Stage2 
might wait 30 seconds or so before executing.

Actions
Actions are needed to represent the component task(s) of a stage.  Each stage can consist of 1..* actions.  There is no reason for a stage to have 0 actions, this would be a waste of resources.  Multiple actions can
exist in a stage, however, this is not recommended because the transaction system's rollback is based on stages not actions.  Thus, if you rollback, the all actions in that stage will be lost.

Rollback
For the system to rollback transactions each stage must have a common input/output.  Since transactions are made to communicate with couchdb we must consider the types of commands supported by couchdb.  Command types
currently supported are:
(1) delete attachment
	Implement? - This will not be implemented because it is a one show pony.  As with other deletes, they are used to remove content and each removes all content within.  Thus, the cumulative needs for removal are
		already accomplished within couchdb.
(2) delete database
	Implement? - see above.
(3) delete document
	Implement? - see above.
(4) get attachment
	Implement? - No.  Because it is set to provide a stream accessing the content of the data file.  This could be massive and our transaction system should not be concerned with the actual data of the file.  That
		is a concern of implementing software as it is supplied from that implementing software.
(5) get database
	Implement? No.  While the command is useful for database statistics, there is not a time that it would be useful in a transaction.  When would we ever change this information?  Never.
(6) get document
	Implement? Yes.  Getting a document is useful to implement because the document can be modified and then saved.
(7) get view
	Implement? No.  We use views to obtain a collection of users and groups.  While users and groups are documents and changes can be completed in bulk, it would not make sense to get all the users or groups to 
		make changes to them.  Besides, the security system maintains a collection of all groups in memory, bulk updates could be better supported through that interface.
(8) head attachment
	Implement? No.  Heading gets the revision information and content type and length.  This is not content itself to be changed.  So, this information is useless as a stage itself.  However, it could be quite useful
		within a stage to determine a path of execution, but for our purposes, it is not an action.
(9) head document
	Implement? No. See above.
(10) post bulk document
	Implement? Yes.  This allows for atomic commit of multiple documents within couchdb.  Enough said.
(11) put attachment
	Implement? No.  Again, an attachment holds the content of a file supplied by the implementing software.  This is outside the scope of the storage system and thus, attempting to manage that data becomes outside 
		our scope and exposes potential mine field of issues since we cannot predict the data.
(12) put database
	Implement? No.  Since all information for the storage library is going to be stored in a single database that is created only once, it is pointless to code for the ability to create a database as we have currently
		accomplished our need using a string and passing that string through a bulk post command.
(13) put document
	Implement? Yes.  This allows for saving changes to the document.  Again, enough said.

Since we know the types of actions we want to support we just need to determine the inputs and outputs and then we can generalize them to determine our classifications or types of actions.  Thus, we have:
(1) get document
	Input - (1) Location within couchdb, (2) the document itself (string or object)
	Output - (1) the document
(2) post bulk document
	Input - (1) a collection of documents (string or objects)
	Output - (1) the results
(3) put document
	Input - (1) the document itself (string or object)
	Output - (1) the result

Now that we know the I/O we can determine our types of actions.  At a basic level these are: (1) Get and (2) Save.  However, we need to note that fact that a bulk post returns a collection of ids and revs representing
the documents saved and their new revision.  No conflict information is returned, but we can ignore that because our system is designed to prevent the possibility of conflict through our implementation of checking out
a resource to allow only a single user to make modifications.  However, it is possible that a single user could create a conflict by using multiple machines (e.g., checkout on machine A, checkout on B, change on B, 
change on A, commit A, commit B).  Thus, whenever a bulk post is going to be preformed, we must be cautious and ensure only a single instance of each document attempts to update.  This can be accomplished by heading 
each document to ensure revision consistency.  This does introduce a race condition (e.g., A checks and gets a go at the same time B is checking and gets a go, both commit, only 1 will be served by couchdb producing 
a conflict that is hidden).  To prevent this, we will need an internal thread-safe access/locking system with which each bulk post will register and take a lock.

Back to our types of actions.  Get takes either a location on couchdb, a copy of the document itself or an object that can become a document (through use of Transitions) and provides a document.  However, a save can
take one or many documents and provides one or many results.  Thus, we should have (2) Save as a base of (A) SaveBulk and (B) SaveSingle.


Transaction Journaling
To journal the transaction stages we will make use of the filesystem.

/root
	/transactions
		/master
			/[_id_of_doc] - a text file containing only the transaction id for the transaction to which this belongs
		/stages
			/[transaction_id]
				/0
				/1
				...

Transactions Namespace

Tasks.Remoting.Base (abstract)
- JObject _input
- JObject _output;

Tasks.Remoting.Get : Base
+ Get(Uri)
+ Get(Model.Document) <- Implementing classes will need to run their respective transition.  Used when the Document has already been downloaded instead of downloading again.
+ Download();

Tasks.Remoting.Save : Base
+ Save(IDatabase, JObject) <- Implementing classes will need to run their respective transition.
+ virtual Upload();

Tasks.Remoting.SaveBulk : Save
+ SaveBulk(IDatabase, List<Model.Document>)

Tasks.Remoting.SaveSingle : Save
+ SaveSingle(IDatabase, Model.Document)


Tasks.Base
Tasks.CreateNewResource - (1) Download ResourceUsageRightsTemplate, (2) Check Permissions, (3) Upload, (4) Return
Tasks.ModifyResource - (1) Download Resource, (2) Check Permissions, (3) Upload, (4) Return
Tasks.GetResource - (1) Download Resource, (2) Check Permissions, (3) Return
Tasks.CreateNewVersion - (1) Download Resource, (2) Check Permissions, (3) Update Resource, (4) Upload (bulk Resource/Version), (5) Return
...


Tasks.Processes.Base
Tasks.Processes.DownloadResourceUsageRightsTemplate
Tasks.Processes.CheckPermissions
Tasks.Processes.UploadResource
Tasks.Processes.DownloadResource
Tasks.Processes.UploadBulk
...


Transaction
+ Transaction()
+ AddAction(Tasks.Base)
+ Begin()
+ Begin(Model.Document)
+ Begin(Tasks.Remoting.Base)
+ Execute()
+ Commit(Tasks.Remoting.Base)


