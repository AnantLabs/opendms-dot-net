Single Command Problem

Problem: If a command times out or errors then it leaves the database in an unknown state.

If an error occurrs it is more likely that data storage was a failure.  If a timeout occurrs we have no idea if data storage was successful.  So, even though an error has a better probability, its probability
is not 100% so we should not assume.  Thus, we need a mechanism to either (1) tell the adopting system to handle it ("Not My Problem"), or (2) internally continue attempting until success ("Brute Force") or 
(3) revert the document to the previous state ("Rollback").

Review of Possibilities
1) "Not My Problem" - this is a library, one option is to simply say that it is not our problem, its the developer using this library's problem to figure out the "state" of errors encountered by our library.
This is the cheap way out by cutting the socket, blocking other events and giving the developer an event to which they subscribe.  I do not like this approach as this library should be self-managing when possible.
Thus, this can be a fallback if other possibilities do not work.

2) "Brute Force" - continuously banging at the door until we get the answer we want is not a good solution because what if that answer never comes?  A possibility would be a certain number of attempts before
returning a failure (e.g., smtp retries).

3) "Rollback" - this requires some sort of state awareness, even if it is as simple as undoing the last action.  This also presents a problem, because if there was an error or timeout, it is most likely to remain
a problem for the immediate future (code, network, hardware issues, etc.)  


Possible Solutions
1) Transaction system - send the transaction system the info, it will eventually become consistent.  Problem is what if the user wants it consistent now and it is not - this leads to essentially recreating the DB.

2) Fire, Error, Check, Return - send the message, if an error or timeout is received, then terminate that connection, opening a new connection after the errored connection is closed that checks the state.  If
that connection again errors, then tell the developer.  If it does not error, then return the success or failure of the first connection.


Solution
#2 above - this maintains a real-time accountability to the developer as would be expected of a library and doesn't simply say its not my problem as it attempts to determine the status.  


----------------------------------------------------------

Multi-Command Problem

Problem: CouchDB supports bulk atomic operations on documents.  However, stand-alone attachments are not included.  Thus, we could bulk commit documents, but we would need to support state management for 
attachments.

Situational Example: Create a new version: (1) lock resource, (2) get current version from resource, (3) create next version, (4) update resource

This will require some sort of transaction system.  I am unable to find one, meaning it must be developed.